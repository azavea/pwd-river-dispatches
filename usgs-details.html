<!DOCTYPE html>
<html lang="en">
<head>
    <style type="text/css">
        body {
            font-family: 'Gill Sans', 'Gill Sans MT', 'Myriad Pro', 'DejaVu Sans Condensed', Helvetica, Arial, sans-serif;
        }

        .container {
            width: 700px;
            height: 700px;
            background-color: #000000;
            margin-top: 240px;
            margin-left: 205px;
            color: #ffffff;
        }

        #sensor-data {
            margin-top: 15px;
            margin-bottom: 15px;
            margin-left: 10px;
        }

        #value {
            font-size: 48px;
        }

        #units {
            font-size: 36px;
        }

        #header,
        #subtext {
            font-size: 24px;
            width: 250px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="header"></div>
        <div id="sensor-data">
            <span id="value"></span>
            <span id="units"></span>
        </div>
        <div id="subtext"></div>
    </div>
    <script type="text/javascript">
        // String constants
        var VERY_LOW  = 'Very Low',
            LOW       = 'Low',
            MODERATE  = 'Moderate',
            HIGH      = 'High',
            VERY_HIGH = 'Very High',
            PRIMARY_SENSOR_URL = // Schuylkill River gage
                'https://waterservices.usgs.gov/nwis/iv/?format=json&sites=01474500',
            BACKUP_SENSOR_URL = // Delaware River gage
                'https://waterservices.usgs.gov/nwis/iv/?format=json&sites=014670261';

        // Metrics configuration
        var METRICS = {
            temperature: {
                code: '00010',
                units: 'Â°F',
                transform: function(c) {
                    var f = c * 9 / 5 + 32;
                    return Math.round(f * 10) / 10;
                },
                fallback: [
                    42, 32, 42, 51, 61, 71, 80, 90, 80, 71, 61, 51
                ],
                display: 'temperature',
            },
            ph: {
                code: '00400',
                units: '',
                transform: function(ph) { return ph; }, // Identity
                fallback: [
                    5.5, 5, 5.5, 6, 6.5, 7, 7.5, 8, 7.5, 7, 6.5, 6
                ],
                display: 'pH',
            },
            dissolvedOxygen: {
                code: '00300',
                units: 'mg/L',
                transform: function(dO) { return dO; }, // Identity
                fallback: [
                    10, 12, 10, 8, 6, 4, 2, 1, 2, 4, 6, 8
                ],
                display: 'oxygen',
            },
            salinity: {
                code: '00095',
                units: 'ppm',
                transform: function(uScm) {
                    var ppm = uScm / 1.56;
                    return Math.round(ppm);
                },
                fallback: [
                    848, 1000, 848, 697, 545, 393, 242, 90, 242, 393, 545, 697
                ],
                display: 'salinity',
            },
            turbidity: {
                code: '63680',
                units: '',
                transform: function(t) {
                    // TODO Convert number to VERY_LOW to VERY_HIGH
                    // https://github.com/azavea/pwd-river-dispatches/issues/16
                    return t;
                },
                fallback: [
                    VERY_LOW, VERY_LOW, LOW, LOW, MODERATE, MODERATE, HIGH, VERY_HIGH, HIGH, HIGH, MODERATE, LOW
                ],
                display: 'turbidity',
            },
        };

        // Hat tip https://stackoverflow.com/a/901144/6995854
        // Utility function to get query parameter
        function getQueryParameterByName(name, url) {
            if (!url) url = window.location.href;
            name = name.replace(/[\[\]]/g, "\\$&");
            var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"),
                results = regex.exec(url);

            if (!results) {
                return null;
            }
            if (!results[2]) {
                return '';
            }

            return decodeURIComponent(results[2].replace(/\+/g, " "));
        }

        // Utility function to generate USGS request URL for a metric
        function urlForMetric(metric, sensorUrl) {
            return sensorUrl + '&parameterCd=' + metric.code;
        }

        // Function to capture results of USGS and populate values
        function handleXHRResponse(metric, isBackupSensor) {
            return function() {
                var value = metric.fallback[new Date().getMonth()],
                    units = metric.units,
                    isFallback = true;

                if (this.status === 200) {
                    var json = JSON.parse(this.responseText);

                    try {
                        var apiValue = json.value.timeSeries[0].values[0].value[0].value;
                        var apiUnits = json.value.timeSeries[0].variable.unit.unitCode;
                        console.log('From API: ' + apiValue + ' ' + apiUnits);

                        value = metric.transform(apiValue);
                        isFallback = false;
                    } catch (ex) {
                        console.warn('Error while parsing result: ' + ex.message);
                    }
                } else {
                    console.warn('Error while fetching USGS data: ' + this.status);
                    console.log('Using fallback values');
                }

                return renderData(value, units, metric, isFallback, isBackupSensor);
            };
        }

        // Handle XHR errors by using fallback data
        function handleXHRError(metric) {
            return function() {
                var value = metric.fallback[new Date().getMonth()],
                    units = metric.units,
                    isFallback = true;

                console.warn('Error while fetching USGS data; using fallback values');

                return renderData(value, units, metric, isFallback);
            }
        }

        // Create header text for live and fallback values
        function renderHeader(metric, isFallback, isBackupSensor) {
            if (isFallback) {
                return 'Typical ' + metric.display + ' in the Schuylkill River:';
            }

            if (isBackupSensor) {
                return 'Current ' + metric.display + ' in the Delaware River:';
            }

            return 'Current ' + metric.display + ' in the Schuylkill River:'
        }

        // Create subtext for live and fallback values
        function renderSubtext(isFallback, isBackupSensor) {
            if (isFallback) {
                return 'A common sensor reading for this month.';
            }

            if (isBackupSensor) {
                return 'The Schuylkill River is the Delaware\'s largest tributary.';
            }

            return 'This reading comes from a nearby sensor.'
        }

        // Write live or fallback values to the document
        function renderData(value, units, metric, isFallback, isBackupSensor) {
            document.getElementById('value').innerText = value;
            document.getElementById('units').innerText = units;
            document.getElementById('header').innerText =
                renderHeader(metric, isFallback, isBackupSensor);
            document.getElementById('subtext').innerText =
                renderSubtext(isFallback, isBackupSensor);
        }

        // Function to fetch values from USGS sensor given a metric and sensorId
        function fetchDataForMetric(metric, sensorId) {
            var url = urlForMetric(metric, sensorId);
            var xhr = new XMLHttpRequest();
            var isBackupSensor = sensorId === BACKUP_SENSOR_URL;

            console.log('Fetching data from sensor ' + sensorId + ': ' + url);

            xhr.addEventListener('load', handleXHRResponse(metric, isBackupSensor));

            if (sensorId === PRIMARY_SENSOR_URL) {
                xhr.addEventListener('error', function() {
                    return fetchDataForMetric(metric, BACKUP_SENSOR_URL);
                });
            } else {
                xhr.addEventListener('error', handleXHRError(metric));
            }

            xhr.open('GET', url);
            xhr.send();
        }

        // Get metric from Query Parameter and fetch and populate values
        window.onload = function() {
            var metric = METRICS[getQueryParameterByName('metric')];
            if (!metric) {
                console.warn('Could not find metric for ' + metric);
                return;
            }

            fetchDataForMetric(metric, PRIMARY_SENSOR_URL);
        };
    </script>
</body>
</html>
